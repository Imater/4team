# ES-2015 (ES6) в React приложениях

### Использование ES-2015 в React приложениях

React приложения используют практически всю гамму новых операторов ES-2015. Сейчас многие браузеры уже реализуют этот стандарт сами, но всё же на этапе сборки проекта при помощи Babel, большинство операторов преобразуются в старый стандарт ES5, чтобы расширить использование на все используемые браузеры, в том числе старых версий.

Для экспериментов над новыми операторами, вы вполне можете использовать Chrome Developer Tools и его консоль.

## Операторы из ES-2015, которые нужно знать в порядке убывания популярности использования

### Переменные: let и const
Стандартный javascript многие критикуют за счёт неоднозначности использования var переменных. За счёт hoisting, замыканий, глобальной области видимости с этим типом переменных часто возникают путанница. Чтобы устранить неоднозначность, были введены два новых способа объявления переменных.
#### let 
Область доступности этой изменяемой переменной ограничена внутри области видимости. Переменная объявленная при помощи `let` может меняться по значению.

Переменная объявленная при помощи let видна только после объявления, т.е. hoisting не применяется.

При использовании в цикле, переменная объявленная при помощи let создаётся каждый раз своя переменная и действует только внутри цикла. Это помогает избежать вот такой ситуации:
```javascript
for(var i=0; i<10; i++) { /* … */ }

alert(i); // 10
```

#### const
Создание константы, т.е. то что объявленно при помощи const никогда не поменяется по значению. Но тут нужно понимать, что если в const лежит ссылка на объект, то свойства объекта менять всё же можно.

```javascript
const obj = { test: 'first value'}
obj.test = 'second value'
console.log(obj.test) // second value
```

Очень часто const используется для объявления анонимных функций, например анонимных стрелочных
```javascript
const fn = item => console.log(item)
fn('test') // console output: test
```
Использование let в таких случаях, как правило избыточно и вызовет ошибку eslint (инструмент статического анализа кода для обеспечения стандартов форматирования кода).

var читается устаревшей конструкцией и лучше её не использовать 

### Деструктуризация

Рассмотрена в отдельном уроке, её пример:

```javascript
for(var i=0; i<10; i++) { /* … */ }
alert(i); // 10
```

### Функции

#### Теперь можно использовать параметры по умолчанию
```javascript
function getParams(options = {option1: true, option2: false}) {
  console.log(options.option1)
}
```

#### Теперь можно использовать `spread` вместо `arguments`
```javascript
const joinArguments = (first, ...args) => [first, ...args].join(', ')
joinArguments('1', '2', '3', '4') // === "1, 2, 3, 4"
```
args может быть только в конце, так как собирает все оставшиеся параметры в массив.

#### Деструктуризация в параметрах функции
```javascript
const joinArguments = ({ first, second }) => [first, second].join(', ')
joinArguments({ first: '1', second: '2', third: '3', fourth: '4') // === "1, 2"
```
Обратите внимание, что использование объекта как аргумент функции добавляет возможность именовать переменные прямо при их перечислении, что немногословно повышает читаемость функции, по сравнении с перечислением аргументов через запятую.

#### Имя в свойстве функции `name`
Теперь даже анонимные функции имеют своё название и оно берется из имени константы в которую сохраняется эта функция. Это удобно для отладки и вывода ошибок.
```javascript
const joinArguments = ({ first, second }) => [first, second].join(', ')
console.log(joinArguments.name) // joinArguments
```

#### function объявленная в области видимости
Теперь функция доступна только после объявления и её область видимости не поднимается при помощи hoisting, что позволяет исключить неоднозначность использования.

#### Стрелочные функции
Теперь функции можно объявлять короткой формой записи при помощи "=>":
```javascript
const log = text => `log: ${text}` 
console.log(log('test') // log: test
```
Когда аргумент один, можно записывать без скобок, когда несколько, нужно писать вот так:
```javascript
const log = (text, type = 'log') => console[type](text)
log('test', 'info') // test
```
Если вы поставили скобки или оператор возращающий результат, то `return` писать не нужно, результат функция вернёт самостоятельно. В случае большого кол-ва операторов, нужно уже использовать фигурные скобки и `return` внутри.
```javascript
const log = (text, type = 'log') => {
  console[type](text)
  return text
}
log('test', 'info') // test
```

Стрелочные функции не имеют this, они используют тот же, что и снаружи. Это позволяет внутри компонентов React задавать функции без использования bind(this) для передачи контекста. Внутри this будет равно классу:
```javascript

import React, { PureComponent, PropTypes } from 'react'

class AdaptiveHeader extends PureComponent {
  static propTypes = {
    containerQuery: PropTypes.object
  }
  handleClick = () => console.log(this)
  render() {
    return (
      <button onClick={this.handleClick}>click</button>
    )
  }
}

export default AdaptiveHeader

```
При клике в кнопку, будет выводиться в консоль сам инстанс класса AdaptiveHeader

#### Внутри стрелочной функции нет arguments

### Классы
Классы позволяют без использования prototype напрямую наследовать другие классы. Таким образом в React создаются компоненты.
```javascript
class Название [extends Родитель]  {
  constructor
  методы
}
```
При рассказе про компоненты, будут рассказаны все особенности классов. Что нужно знать про классы: Статические свойства, свойства инстанса, наследование, передача контекста this, метод constructor, использование super, геттер, сеттеры и вычисляемые свойства. С этим вы можете ознакомиться вот тут: https://learn.javascript.ru/es-class

### Строки

#### Появились шаблоны, которые позволяют компакно конкатенировать строки:
```javascript
const rub = value => `${value} руб.`
```
Обратите внимания, что в косых ковычках поддерживаются переносы текста и они будут выводиться

#### Функции шаблонизации
Вы можете написать свою функцию шаблонизации и переиспользовать
```javascript
function f(strings, ...values) {
  alert(JSON.stringify(strings));     // ["Sum of "," + "," =\n ","!"]
  alert(JSON.stringify(strings.raw)); // ["Sum of "," + "," =\\n ","!"]
  alert(JSON.stringify(values));      // [3,5,8]
}

let apples = 3;
let oranges = 5;

//          |  s[0] | v[0] |s[1]| v[1]  |s[2]  |      v[2]      |s[3]
let str = f`Sum of ${apples} + ${oranges} =\n ${apples + oranges}!`;
```

### Классы
### Объекты и прототипы

#### Короткое свойство
Теперь можно писать коротко:
```javascript
const isRed = true
const isGreen = false
const option = {
  isRed,
  isGreen
}
```

#### Вычисляемые свойства
Теперь имя свойства, которому присваивается значение, можно брать из переменных. Запись, которая ниже, перезаписывает верхние.
```javascript
const isRed = true
const isGreen = false
const name = isGreen
const option = {
  isRed,
  isGreen,
  [name]: true
}
```

#### Новые сметоды Object

Вы можете использовать разные методы для смешивания свойств `Object.assign`, для сравнения `Object.is`.

Теперь вместо ключа и свойства, в объектах можно размещать функции и им в this доступен сам объект:
```javascript
const isRed = true
const option = {
  isRed,
  sayIsAmIRed() {
    console.log(this.isRed)
  }
}
```

#### super
Позволяет вызывать функции своего предка
```javascript
const animal = {
  walk() {
    alert("I'm walking");
  }
};

const rabbit = {
  __proto__: animal,
  walk() {
    alert(super.walk); // walk() { … }
    super.walk(); // I'm walking
  }
};

rabbit.walk();
```

### Promise
### Модули
### Set, Map, WeakSet и WeakMap
### Генераторы
### Proxy
### Тип данных Symbol
### Итераторы
Также в es-2015 появились новые возможности, которые используются чуть реже, но мы большинство их будем рассматривать по мере изучения React. Подробнее можно ознакомиться вот тут: https://learn.javascript.ru/es-modern
