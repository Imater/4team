# Диагностика производительности

### Perf
Позволяет выявлять компоненты, которые перерисовываются без причины. Позволяет анализировать время рендера компонентов.
React Addons Perf - расширение хрома, которое позволяет запускать и останавливать сбор статистики.

*Демо:* Запуск неоптимизированного короткого приложения с списком элементов, вывод таблицы производительности.

### Developer Tools
Позволяет: 
- проводить глубокий анализ кода
- анализировать производительности
- анализировать потребления памяти
- отображение перерендера
- дебаг 
- пользоваться React расширением хрома
- пользоваться Redux расширением хрома
- отображать хранилище redux
- условные точки остановки
– Elements Panel показывает изменения и перерендер компонентов в реакт
– React Perf on Timeline

*Демо:* Показать основной функционал из списка, рассказать как использовать на практике, научить проводить отладку приложений без изменения кода

### Console
- console.time
- console.assert
- console.group
- console.log
- console.profile
- console.trace
*Демо:* Добавление отладочных сообщений без изменения кода

### Использование window.perfomance
Позволяет в коде ставить метки с названием компонента или страницы для более удобного анализа производительности

### FPS Meter
Позволяет вовремя диагностировать падение производительности, особенно при scroll, websocket

### Пропатченный connect
Отображает все случае бесполезного перерендера контейнера с `@connect` функцией при изменённом `props`, который изменился по ссылке, но остался прежним по содержанию

### Angular компонент
Позволяет использовать Trace React Updates

# Ускоряем время старта приложения на React

### NODE_ENV === 'production'
Ускорение производительности при NODE_ENV === 'production', за счёт внутренней оптимизации, минификации кода и стилей, отключения части функционала дебага и вывода ошибок и предупреждений.
Внутренние оптимизации внутри React при production через плагины: https://krambertech.github.io/react-perf-talk/assets/player/KeynoteDHTMLPlayer.html#10:
– React Constant Elements Transform - перенос вёрстки в константы
– React Inline Elements Transform
– React RemovePropTypes Transform
– Transform Pure Class To Function - объяснить, что делать это вручную уже не требуется
– React optimize preset

### Указать версии поддерживаемых браузеров
Если их не указать, то будет очень много полифилов и оптимизаций для старых браузеров

### Минифицировать CSS
Указать версии IE, чтобы уменьшить кол-во префиксов в стилях

### Source Map Explorer
NPM пакет, позволяет визуально показать содержимое bundle и понять, какие npm пакеты импортированы неоптимально или зря. Можно провести оптимизацию, например отключив лишние локали, импортируя функции, а не пакеты целиком при помощи Modular import. Рассказать что такое Webpack Tree Shaking

### Eslint 
Позволит найти и исправить все неоптимальные места в коде и поддерживать код в рамках установленных правил

### Extract CSS
Выделить CSS файлы для каждого бандла

### React router
Выделить код в bundle для каждого элемента url, подгружать код только когда он понадобился.

# Причины плохой производительности React и методы исправления

### Изменившиеся ссылки в props при том же содержимом
Рассмотрим все варианты изменения props, которые можно было избежать:
- функции
- списки
– хранилища
– запросы в сеть и другие асинхронные операции
– кэширование фильтрации, отбора и сортировки элементов в браузере

Инструменты, которыми можно избежать бесполезных перерендеров:
– asyncConnect, позволит отложить первый рендер до загрузки всех данных с сети
– серверный рендеринг SSR (в том числе группирует загрузку всех данных с сети)
– preventRenderWhileLoading
- оптимизация использования state
- глубокое понимание lifecycle Реакт компонентов
– stateless component
– pureComponent
– function.bind / arrow функции - рассказать про особенности. Рассказать про родные реакт-компоненты и нужно ли там оптимизировать `prop`.
– как прокидывать id списка в универсальную функцию
– bind в конструкторе
– рассказать про Компонент, экземпляр компонента, как работают функции разных реализаций
– рассказать про то, что создаёт новые ссылки и как сравниваются объекты, массивы, функции, хранилища, подхранилища. Как правильно прокидывать option объекты (выносить в константы или импортировать). Частые ошибки, например options || [], исправляются созданием emptyArray, emptyObject
– необходимость defaultProps и правило, что компонент должен рендериться без единого `prop`
– запрет на мутацию объектов, привести пример с `arr1.push(4) === arr1`

### shouldComponentUpdate
PureRender - рассказать как осуществляется сравнение для вычисления shouldComponentUpdate и что нужно добавлять при своих условиях в этой функции

### Оптимизация списков
Влияние key на перерендер. Разбиение на компоненты. Недостаток key === index

### Перенос тяжёлых вычислений в componentDidMount или componentWillMount
Кеширование, сброс кеша, обновление

### Недостаточное разбиение на компоненты и контейнеры
– Если компонент имеющий состояние (например контейнер), написан внутри большого компонента, то он будет перерендериваться. 
– Контейнеры должны брать только те данные, которые им нужны
– Приём, когда один контейнер управляет только списком с id, а отображают строки уже другие контейнеры, получающие id как `prop`
– Рассказать про иерархию перерендера, в том числе при PureComponents

# Причины плохой производительности Redux и методы исправления
Инструменты исправления:
– reselect с правилом создания селекторов, которые позволяют их легко переиспользовать и комбинировать
– memoizee
– передача в коннект mapDispatchToProps
### Один большой контейнер, против нескольких маленьких
### Рассказать как выглядит redux внутри 
### Как избавиться от switch в редьюсерах (redux-act) 
### Как использовать данные одного хранилища в другом
### Redux ignore библиотека для экшенов, которые не меняют state
### redux-log-slow-reducers
Глобально ставится и показывает все медленные action
### redux-batch
Библиотеки позволяют объединять несколько экшенов, синхронно меняющие хранилище за один раз и только потом вызывающие перерендер
### Знакомство с ramda основными функциями

### Методы обработки асинхронных действий
#### redux-loop
#### redux-thunk
#### redux-saga
#### mobX (RxJs)

# Улучшение читаемости и увеличение переиспользования функций и компонентов
Инструменты:
– High Order Reducer
– High Order Functions
– High Order Components
– Комбинирование компонентов с переиспользованием функций и стилей
– Перенос и переиспользование компонентов и библиотек компонентов в отдельные npm пакеты
– Принципы SOLID в react приложениях

# Ускорение написания кода, использование шаблонизатора компонентов

# Особенности при серверном рендеринге SSR
– Импорты происходят один раз и ни в коем случае нельзя хранить состояния за экземпляром класса
– Особенности работы с cookies, localStorage, url при SSR
– Контекст реакт приложений и библиотека inject для прокидывания экземпляров библиотек и данных

# Методы не ускоряющие производительность, но создающие такие ощущения
Рассказ про активное и пассивное ожидание пользователя
- Запрет на мелькание лоадеров, доводка лоадера
– Плейсхолдеры вместо информации, которые потом заменятся информацией (пререндер)
– Когда использовать лоадер-спиннер (1-4с), прогрессбар (>4с)
– Отображение данных только после полной загрузки всего, в том числе изображений 
– Кэширование данных уже посещённых страниц

# Оптимистическое обновление
- Алгоритм

# Работа с redux-form

## Оптимизация работы с АПИ

#### Ajax запросы
возможность отмены запросов, интерсепторы в axios

#### Ajax запросы HTTP2

#### Websocket запросы

# Скролинг с фоновой автоподзагрузкой с оптимизацией перерендера невидимых компонентов
react virtualized библиотека

# Typescript, flow
Приемущество типизированных языков
